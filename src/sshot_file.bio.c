// This file is automatically generated by bio.pl
//   source: sshot_file.bio
//   namespace: sshot_file

#include "sshot_file.bio.h"

int sshot_file_Copy_hdr( sshot_file_hdr_t* const dst, const sshot_file_hdr_t* const src ) {
	size_t	len;

	dst->magic = src->magic;
	dst->runtime = src->runtime;
	dst->platform = src->platform;
	dst->ssFileVersion = src->ssFileVersion;
	len = dst->vb.len = src->vb.len;
	dst->vb.buf = malloc( len );
	if ( dst->vb.buf == NULL ) {
		return 0;	// ignoring this fatal error of malloc()
	}
	memcpy( dst->vb.buf, src->vb.buf, len );

	return 1;
}

int sshot_file_IsEqual_hdr( const sshot_file_hdr_t* const r1, const sshot_file_hdr_t* const r2 ) {
	if ( r1->magic != r2->magic ) {
		return 0;
	}
	if ( r1->runtime != r2->runtime ) {
		return 0;
	}
	if ( r1->platform != r2->platform ) {
		return 0;
	}
	if ( r1->ssFileVersion != r2->ssFileVersion ) {
		return 0;
	}
	if ( !bbb_bio_IsEqual_varbuf( r1->vb, r2->vb ) ) {
		return 0;
	}

	return 1;
}

size_t sshot_file_GetSize_hdr( const sshot_file_hdr_t* const r ) {
	return ( 0 + sizeof( uint8_t ) + sizeof( uint16_t ) + sizeof( uint32_t ) + sizeof( uint64_t ) + sizeof( r->vb.len ) + r->vb.len );
}

size_t sshot_file_GetSizeArray_hdr( const sshot_file_hdr_t* const a, size_t const n ) {
	size_t	i;
	size_t	sz = 0;

	for ( i = 0; i < n; i++ ) {
		sz += sshot_file_GetSize_hdr( &( a[ i ] ) );
	}
	return sz;
}

size_t sshot_file_ReadFromBuf_hdr( sshot_file_hdr_t* const r, const bbb_byte_t* const buf, const size_t len ) {
	size_t	cur = 0;
	size_t	red;

	if ( cur >= len ) {
		return 0;
	}
	r->magic = *( buf + cur );
	cur++;
	red = bbb_bio_ReadFromBuf_uint16( &( r->runtime ), buf + cur, len - cur );
	if ( red == 0 ) {
		return 0;
	}
	cur += red;
	red = bbb_bio_ReadFromBuf_uint32( &( r->platform ), buf + cur, len - cur );
	if ( red == 0 ) {
		return 0;
	}
	cur += red;
	red = bbb_bio_ReadFromBuf_uint64( &( r->ssFileVersion ), buf + cur, len - cur );
	if ( red == 0 ) {
		return 0;
	}
	cur += red;
	red = bbb_bio_ReadFromBuf_varbuf( &( r->vb ), buf + cur, len - cur );
	if ( red == 0 ) {
		return 0;
	}
	cur += red;
	return cur;
}

size_t sshot_file_ReadFromBufArray_hdr( sshot_file_hdr_t* const a, size_t const n, const bbb_byte_t* const buf, const size_t len ) {
	size_t	i;
	size_t	cur = 0;
	size_t	red;

	for ( i = 0; i < n; i++ ) {
		red = sshot_file_ReadFromBuf_hdr( &( a[ i ] ), buf + cur, len - cur );
		if ( red == 0 ) {
			sshot_file_DestroyEach_hdr( a, i );
			return 0;
		}
		cur += red;
	}
	return cur;
}

size_t sshot_file_WriteToBuf_hdr( const sshot_file_hdr_t* const r, bbb_byte_t* const buf, const size_t len ) {
	size_t	cur = 0;
	size_t	wtn;

	if ( cur >= len ) { return 0; }
	*( buf + cur ) = r->magic;
	cur++;
	wtn = bbb_bio_WriteToBuf_uint16( r->runtime, buf + cur, len - cur );
	if ( wtn == 0 ) { return 0; }
	cur += wtn;
	wtn = bbb_bio_WriteToBuf_uint32( r->platform, buf + cur, len - cur );
	if ( wtn == 0 ) { return 0; }
	cur += wtn;
	wtn = bbb_bio_WriteToBuf_uint64( r->ssFileVersion, buf + cur, len - cur );
	if ( wtn == 0 ) { return 0; }
	cur += wtn;
	wtn = bbb_bio_WriteToBuf_varbuf( r->vb, buf + cur, len - cur );
	if ( wtn == 0 ) { return 0; }
	cur += wtn;
	return cur;
}

size_t sshot_file_WriteToBufArray_hdr( const sshot_file_hdr_t* const a, size_t const n, bbb_byte_t* const buf, const size_t len ) {
	size_t	i;
	size_t	cur = 0;
	size_t	wtn;

	for ( i = 0; i < n; i++ ) {
		wtn = sshot_file_WriteToBuf_hdr( &( a[ i ] ), buf + cur, len - cur );
		if ( wtn == 0 ) { return 0; }
		cur += wtn;
	}
	return cur;
}

size_t sshot_file_ReadFromFile_hdr( sshot_file_hdr_t* const r, FILE* const f, bbb_checksum_t* const chk ) {
	size_t	cur = 0;
	size_t	red;

	if ( fread( &( r->magic ), 1, 1, f ) == 0 ) {
		return 0;
	}
	bbb_util_hash_UpdateChecksum( &( r->magic ), 1, chk );
	cur++;
	red = bbb_bio_ReadFromFile_uint16( &( r->runtime ), f, chk );
	if ( red == 0 ) {
		return 0;
	}
	cur += red;
	red = bbb_bio_ReadFromFile_uint32( &( r->platform ), f, chk );
	if ( red == 0 ) {
		return 0;
	}
	cur += red;
	red = bbb_bio_ReadFromFile_uint64( &( r->ssFileVersion ), f, chk );
	if ( red == 0 ) {
		return 0;
	}
	cur += red;
	red = bbb_bio_ReadFromFile_varbuf( &( r->vb ), f, chk );
	if ( red == 0 ) {
		return 0;
	}
	cur += red;
	return cur;
}

size_t sshot_file_ReadFromFileArray_hdr( sshot_file_hdr_t* const a, size_t const n, FILE* const f, bbb_checksum_t* const chk ) {
	size_t	i;
	size_t	cur = 0;
	size_t	red;

	for ( i = 0; i < n; i++ ) {
		red = sshot_file_ReadFromFile_hdr( &( a[ i ] ), f, chk );
		if ( red == 0 ) {
			sshot_file_DestroyEach_hdr( a, i );
			return 0;
		}
		cur += red;
	}
	return cur;
}

size_t sshot_file_WriteToFile_hdr( const sshot_file_hdr_t* const r, FILE* const f, bbb_checksum_t* const chk ) {
	size_t	cur = 0;
	size_t	wtn;

	bbb_util_hash_UpdateChecksum( &( r->magic ), 1, chk );
	if ( fwrite( &( r->magic ), 1, 1, f ) == 0 ) { return 0; }
	cur++;
	wtn = bbb_bio_WriteToFile_uint16( r->runtime, f, chk );
	if ( wtn == 0 ) { return 0; }
	cur += wtn;
	wtn = bbb_bio_WriteToFile_uint32( r->platform, f, chk );
	if ( wtn == 0 ) { return 0; }
	cur += wtn;
	wtn = bbb_bio_WriteToFile_uint64( r->ssFileVersion, f, chk );
	if ( wtn == 0 ) { return 0; }
	cur += wtn;
	wtn = bbb_bio_WriteToFile_varbuf( r->vb, f, chk );
	if ( wtn == 0 ) { return 0; }
	cur += wtn;
	return cur;
}

size_t sshot_file_WriteToFileArray_hdr( const sshot_file_hdr_t* const a, size_t const n, FILE* const f, bbb_checksum_t* const chk ) {
	size_t	i;
	size_t	cur = 0;
	size_t	wtn;

	for ( i = 0; i < n; i++ ) {
		wtn = sshot_file_WriteToFile_hdr( &( a[ i ] ), f, chk );
		if ( wtn == 0 ) { return 0; }
		cur += wtn;
	}
	return cur;
}

void sshot_file_Destroy_hdr( sshot_file_hdr_t* const r ) {
	free( r->vb.buf );
	r->vb.buf = NULL;
	r->vb.len = 0;

}

void sshot_file_DestroyEach_hdr( sshot_file_hdr_t* const a, size_t const n ) {
	size_t	i;

	for ( i = 0; i < n; i++ ) {
		sshot_file_Destroy_hdr( &( a[ i ] ) );
	}
}
