#
# Portable binary records I/O.
# Generates one .h and .c files from .bio definition.
#
# Usage: perl bio.pl --output-dir <outputDir> <bioFilename>
#

use strict;
use warnings;

my @records = ();
my $errors = 0;
my $line = 0;
my $filename = "";
my $namespace = "";
my $outputDir = "";

sub Perr {
	my $s = shift;

	print "line $line: " . $s . "\n";
	$errors += 1;
}

sub ReadBIO {
    my $_;
	my $SYMBOL = "[a-zA-Z_][a-zA-Z_0-9]*";
	my $COMMENTS = "\\s*(?:\\/\\/.*)?";
	my $inRecord = 0;
	my $f;

	$errors = 0;
	$line = 0;

	open $f, $filename or die $!;

	for ( <$f> ) {
		$line += 1;
		if ( /^($SYMBOL)\s+\{$COMMENTS$/ ) {
			# record definition (begin)
			if ( $inRecord ) {
				Perr "The record ( $1 ) is inside another one.";
			} else {
				$inRecord = 1;
				push( @records, { "recName" => $1, "fields" => [] } );
			}
		} elsif ( /^\t($SYMBOL)\s+($SYMBOL);$COMMENTS$/ ) {
			# field definition
			if ( $inRecord ) {
				push( @{ $records[ $#records ]{ "fields" } }, {
					"type" => $1,
					"name" => $2
				} );
			} else {
				Perr "The field ( $1 $2 ) is outside of records.";
			}
		} elsif ( /^\};$COMMENTS$/ ) {
			# record definition (end)
			if ( $inRecord ) {
				$inRecord = 0;
			} else {
				Perr "Unexpected end of a record.";
			}
		} elsif ( /^$COMMENTS$/ ) {
			# skipping
		} elsif ( $_ =~ /^#namespace\s+($SYMBOL)$COMMENTS$/ ) {
			if ( $namespace ) {
				Perr "#namespace is used several times.";
			} else {
				$namespace = $1;
			}
		} else {
			Perr "Corrupted line.";
		}
	}

	if ( !$namespace ) {
		Perr "#namespace is not found.";
	}

	close $f or die $!;
}

sub WriteH {
    my $_;
	my $def = "_" . uc( $namespace ) . "_BIO_H";
	my $f;

	open $f, ">", "${outputDir}/${filename}.h" or die $!;

	print $f "// This file is automatically generated by bio.pl\n";
	print $f "//   source: $filename\n";
	print $f "//   namespace: $namespace\n\n";
	print $f "#ifndef $def\n";
	print $f "#define $def\n\n";
	print $f "#include \"global.h\"\n";
	print $f "#include \"bio.h\"\n\n";

	foreach ( @records ) {
		my $rec = $_;
		my $recName = $rec->{ "recName" };
		my $recType = $rec->{ "recType" } = "${namespace}_${recName}_t";

		$rec->{ "isBytesOnly" } = 1;
		$rec->{ "isDynamic" } = 0;
		print $f "typedef struct {\n";
		foreach ( @{ $rec->{ "fields" } } ) {
			if ( $_->{ "type" } eq "varbuf" ) {
				print $f "	bbb_varbuf_t\t" . $_->{ "name" } . ";\n";
				$rec->{ "isDynamic" } = 1;
				$rec->{ "isBytesOnly" } = 0;
			} elsif ( $_->{ "type" } eq "uint8" ) {
				print $f "	" . $_->{ "type" } . "_t\t\t\t" . $_->{ "name" } . ";\n";
			} else {
				print $f "	" . $_->{ "type" } . "_t\t\t" . $_->{ "name" } . ";\n";
				$rec->{ "isBytesOnly" } = 0;
			}
		}
		print $f "} ${recType};\n\n";

		$rec->{ "proto" } = {};

		$rec->{ "proto" }{ "Copy" }
			= sprintf "int		${namespace}_Copy_${recName}( ${recType}* const dst, const ${recType}* const src )";

		$rec->{ "proto" }{ "IsEqual" }
			= sprintf "int		${namespace}_IsEqual_${recName}( const ${recType}* const r1, const ${recType}* const r2 )";

		$rec->{ "proto" }{ "GetSize" }
			= sprintf "size_t	${namespace}_GetSize_${recName}( const ${recType}* const r )";

		$rec->{ "proto" }{ "GetSizeArray" }
			= sprintf "size_t	${namespace}_GetSizeArray_${recName}( const ${recType}* const a, size_t const n )";

		### Buffer I/O ###

		$rec->{ "proto" }{ "ReadFromBuf" }
			= sprintf "size_t	${namespace}_ReadFromBuf_${recName}( ${recType}* const r, const bbb_byte_t* const buf, const size_t len )";

		$rec->{ "proto" }{ "ReadFromBufArray" }
			= sprintf "size_t	${namespace}_ReadFromBufArray_${recName}( ${recType}* const a, size_t const n, const bbb_byte_t* const buf, const size_t len )";

		$rec->{ "proto" }{ "WriteToBuf" }
			= sprintf "size_t	${namespace}_WriteToBuf_${recName}( const ${recType}* const r, bbb_byte_t* const buf, const size_t len )";

		$rec->{ "proto" }{ "WriteToBufArray" }
			= sprintf "size_t	${namespace}_WriteToBufArray_${recName}( const ${recType}* const a, size_t const n, bbb_byte_t* const buf, const size_t len )";

		### File I/O ###

		$rec->{ "proto" }{ "ReadFromFile" }
			= sprintf "size_t	${namespace}_ReadFromFile_${recName}( ${recType}* const r, FILE* const f, bbb_checksum_t* const chk )";

		$rec->{ "proto" }{ "ReadFromFileArray" }
			= sprintf "size_t	${namespace}_ReadFromFileArray_${recName}( ${recType}* const a, size_t const n, FILE* const f, bbb_checksum_t* const chk )";

		$rec->{ "proto" }{ "WriteToFile" }
			= sprintf "size_t	${namespace}_WriteToFile_${recName}( const ${recType}* const r, FILE* const f, bbb_checksum_t* const chk )";

		$rec->{ "proto" }{ "WriteToFileArray" }
			= sprintf "size_t	${namespace}_WriteToFileArray_${recName}( const ${recType}* const a, size_t const n, FILE* const f, bbb_checksum_t* const chk )";

		$rec->{ "proto" }{ "Destroy" }
			= sprintf "void	${namespace}_Destroy_${recName}( ${recType}* const r )";

		$rec->{ "proto" }{ "DestroyEach" }
			= sprintf "void	${namespace}_DestroyEach_${recName}( ${recType}* const a, size_t const n )";

		foreach ( sort( keys %{$rec->{ "proto" }} ) ) {
			print $f $rec->{ "proto" }{ $_ } . ";\n";
		}

		print $f "\n";
	}

	print $f "#endif\n";
	close $f or die $!;
}

sub IsAtomType {
	return ( shift =~ m/^uint(?:8|16|32|64)$/ );
}

sub Output_ProtoImpl {
	my $f = shift;
	my $proto = shift;

	$proto =~ s/\t+/ /;
	print $f "\n${proto} {\n";
}

sub Output_Assert {
    my $_;
	my $f = shift;
	my $ifexp = shift;
	my $fields = shift;

	print $f "	if ( ${ifexp} ) {\n";
	foreach ( @{$fields} ) {
		print $f "		free( r->$_.buf ); r->$_.buf = NULL; r->$_.len = 0;\n";
	}
	print $f "		return 0;\n";
	print $f "	}\n";
}

sub Output_ReadImpl {
    my $_;
	my $f = shift;
	my $mode = shift;		# ( Buf | File )
	my $rec = shift;
	my $recName = $rec->{ "recName" };
	my @allocated = ();		# collection of fields with dynamically allocated memory

	Output_ProtoImpl( $f, $rec->{ "proto" }{ "ReadFrom${mode}" } );
	print $f "	size_t	cur = 0;\n";
	if ( !$rec->{ "isBytesOnly" } ) {
		print $f "	size_t	red;\n\n";
	}
	foreach ( @{ $rec->{ "fields" } } ) {
		my $type = $_->{ "type" };
		my $name = $_->{ "name" };

		if ( $type eq "uint8" ) {
			if ( $mode eq "Buf" ) {
				Output_Assert( $f, "cur >= len", \@allocated );
				print $f "	r->${name} = *( buf + cur );\n";
			} else {
				Output_Assert( $f, "fread( &( r->${name} ), 1, 1, f ) == 0", \@allocated );
				print $f "	bbb_util_hash_UpdateChecksum( &( r->${name} ), 1, chk );\n";
			}
			print $f "	cur++;\n";
		} else {
			if ( $mode eq "Buf" ) {
				print $f "	red = bbb_bio_ReadFrom${mode}_${type}( &( r->${name} ), buf + cur, len - cur );\n";
			} else {
				print $f "	red = bbb_bio_ReadFrom${mode}_${type}( &( r->${name} ), f, chk );\n";
			}
			Output_Assert( $f, "red == 0", \@allocated );
			print $f "	cur += red;\n";

			if ( $type eq "varbuf" ) {
				push( @allocated, $name );
			}
		}
	}
	print $f "	return cur;\n";
	print $f "}\n";
}

sub Output_ReadArrayImpl {
    my $_;
	my $f = shift;
	my $mode = shift;		# ( Buf | File )
	my $rec = shift;
	my $recName = $rec->{ "recName" };

	Output_ProtoImpl( $f, $rec->{ "proto" }{ "ReadFrom${mode}Array" } );
	print $f "	size_t	i;\n";
	print $f "	size_t	cur = 0;\n";
	print $f "	size_t	red;\n\n";
	print $f "	for ( i = 0; i < n; i++ ) {\n";
	if ( $mode eq "Buf" ) {
		print $f "		red = ${namespace}_ReadFrom${mode}_${recName}( &( a[ i ] ), buf + cur, len - cur );\n";
	} else {
		print $f "		red = ${namespace}_ReadFrom${mode}_${recName}( &( a[ i ] ), f, chk );\n";
	}
	print $f "		if ( red == 0 ) {\n";
	if ( $rec->{ "isDynamic" } ) {
		print $f "			${namespace}_DestroyEach_${recName}( a, i );\n";
	}
	print $f "			return 0;\n";
	print $f "		}\n";
	print $f "		cur += red;\n";
	print $f "	}\n";
	print $f "	return cur;\n";
	print $f "}\n";
}

sub Output_WriteImpl {
    my $_;
	my $f = shift;
	my $mode = shift;		# ( Buf | File )
	my $rec = shift;
	my $recName = $rec->{ "recName" };

	Output_ProtoImpl( $f, $rec->{ "proto" }{ "WriteTo${mode}" } );
	print $f "	size_t	cur = 0;\n";
	if ( !$rec->{ "isBytesOnly" } ) {
		print $f "	size_t	wtn;\n\n";
	}
	foreach ( @{ $rec->{ "fields" } } ) {
		my $type = $_->{ "type" };
		my $name = $_->{ "name" };

		if ( $type eq "uint8" ) {
			if ( $mode eq "Buf" ) {
				print $f "	if ( cur >= len ) { return 0; }\n";
				print $f "	*( buf + cur ) = r->${name};\n";
			} else {
				print $f "	bbb_util_hash_UpdateChecksum( &( r->${name} ), 1, chk );\n";
				print $f "	if ( fwrite( &( r->${name} ), 1, 1, f ) == 0 ) { return 0; }\n";
			}
			print $f "	cur++;\n";
		} else {
			if ( $mode eq "Buf" ) {
				print $f "	wtn = bbb_bio_WriteTo${mode}_${type}( r->${name}, buf + cur, len - cur );\n";
			} else {
				print $f "	wtn = bbb_bio_WriteToFile_${type}( r->${name}, f, chk );\n";
			}
			print $f "	if ( wtn == 0 ) { return 0; }\n";
			print $f "	cur += wtn;\n";
		}
	}
	print $f "	return cur;\n";
	print $f "}\n";
}

sub Output_WriteArrayImpl {
    my $_;
	my $f = shift;
	my $mode = shift;		# ( Buf | File )
	my $rec = shift;
	my $recName = $rec->{ "recName" };

	Output_ProtoImpl( $f, $rec->{ "proto" }{ "WriteTo${mode}Array" } );
	print $f "	size_t	i;\n";
	print $f "	size_t	cur = 0;\n";
	print $f "	size_t	wtn;\n\n";
	print $f "	for ( i = 0; i < n; i++ ) {\n";
	if ( $mode eq "Buf" ) {
		print $f "		wtn = ${namespace}_WriteTo${mode}_${recName}( &( a[ i ] ), buf + cur, len - cur );\n";
	} else {
		print $f "		wtn = ${namespace}_WriteTo${mode}_${recName}( &( a[ i ] ), f, chk );\n";
	}
	print $f "		if ( wtn == 0 ) { return 0; }\n";
	print $f "		cur += wtn;\n";
	print $f "	}\n";
	print $f "	return cur;\n";
	print $f "}\n";
}

sub WriteC {
    my $_;
	my $f;

	open $f, ">", "${outputDir}/${filename}.c" or die $!;

	print $f "// This file is automatically generated by bio.pl\n";
	print $f "//   source: $filename\n";
	print $f "//   namespace: $namespace\n\n";
	print $f "#include \"$filename.h\"\n";

	foreach ( @records ) {
		my $rec = $_;
		my $recName = $rec->{ "recName" };

		# Copy() implementation
		Output_ProtoImpl( $f, $rec->{ "proto" }{ "Copy" } );
		if ( $rec->{ "isDynamic" } ) {
			print $f "	size_t	len;\n\n";
		}
		foreach ( @{ $rec->{ "fields" } } ) {
			my $type = $_->{ "type" };
			my $name = $_->{ "name" };

			if ( IsAtomType $type ) {
				print $f "	dst->${name} = src->${name};\n";
			} elsif ( $type eq "varbuf" ) {
				print $f "	len = dst->${name}.len = src->${name}.len;\n";
				print $f "	dst->${name}.buf = malloc( len );\n";
				print $f "	if ( dst->${name}.buf == NULL ) {\n";
				print $f "		return 0;	// ignoring this fatal error of malloc()\n";
				print $f "	}\n";
				print $f "	memcpy( dst->${name}.buf, src->${name}.buf, len );\n";
			} else {
				die "Unknown field type: $type\n";
			}
		}
		print $f "\n";
		print $f "	return 1;\n";
		print $f "}\n";

		# IsEqual() implementation
		Output_ProtoImpl( $f, $rec->{ "proto" }{ "IsEqual" } );
		foreach ( @{ $rec->{ "fields" } } ) {
			my $type = $_->{ "type" };
			my $name = $_->{ "name" };

			if ( IsAtomType $type ) {
				print $f "	if ( r1->${name} != r2->${name} ) {\n";
			} elsif ( $type eq "varbuf" ) {
				print $f "	if ( !bbb_bio_IsEqual_varbuf( r1->${name}, r2->${name} ) ) {\n";
			} else {
				die "Unknown field type: $type\n";
			}
			print $f "		return 0;\n";
			print $f "	}\n";
		}
		print $f "\n";
		print $f "	return 1;\n";
		print $f "}\n";

		# GetSize() implementation
		Output_ProtoImpl( $f, $rec->{ "proto" }{ "GetSize" } );
		print $f "	return ( 0";
		foreach ( @{ $rec->{ "fields" } } ) {
			my $type = $_->{ "type" };
			my $name = $_->{ "name" };

			print $f " + ";
			if ( IsAtomType $type ) {
				print $f "sizeof( r->${name} )";
			} elsif ( $type eq "varbuf" ) {
				print $f "sizeof( r->${name}.len ) + r->${name}.len";
			} else {
				die "Unknown field type: $type\n";
			}
		}
		print $f " );\n";
		print $f "}\n";

		# GetSizeArray() implementation
		Output_ProtoImpl( $f, $rec->{ "proto" }{ "GetSizeArray" } );
		print $f "	size_t	i;\n";
		print $f "	size_t	sz = 0;\n\n";
		print $f "	for ( i = 0; i < n; i++ ) {\n";
		print $f "		sz += ${namespace}_GetSize_${recName}( &( a[ i ] ) );\n";
		print $f "	}\n";
		print $f "	return sz;\n";
		print $f "}\n";

		# Buffer I/O
		Output_ReadImpl( $f, "Buf", $rec );
		Output_ReadArrayImpl( $f, "Buf", $rec );
		Output_WriteImpl( $f, "Buf", $rec );
		Output_WriteArrayImpl( $f, "Buf", $rec );

		# File I/O
		Output_ReadImpl( $f, "File", $rec );
		Output_ReadArrayImpl( $f, "File", $rec );
		Output_WriteImpl( $f, "File", $rec );
		Output_WriteArrayImpl( $f, "File", $rec );

		# Destroy() implementation
		Output_ProtoImpl( $f, $rec->{ "proto" }{ "Destroy" } );
		if ( $rec->{ "isDynamic" } ) {
			foreach ( @{ $rec->{ "fields" } } ) {
				my $type = $_->{ "type" };
				my $name = $_->{ "name" };

				if ( $type eq "varbuf" ) {
					print $f "	free( r->${name}.buf );\n";
					print $f "	r->${name}.buf = NULL;\n";
					print $f "	r->${name}.len = 0;\n\n";
				}
			}
		} else {
			print $f "	( void ) r;\n";
		}
		print $f "}\n";

		# DestroyEach() implementation
		Output_ProtoImpl( $f, $rec->{ "proto" }{ "DestroyEach" } );
		if ( $rec->{ "isDynamic" } ) {
			print $f "	size_t	i;\n\n";
			print $f "	for ( i = 0; i < n; i++ ) {\n";
			print $f "		${namespace}_Destroy_${recName}( &( a[ i ] ) );\n";
			print $f "	}\n";
		} else {
			print $f "	( void ) a;\n";
			print $f "	( void ) n;\n";
		}
		print $f "}\n";
	}

	close $f or die $!;
}

while ( my $a = shift ) {
	if ( $a eq "--output-dir" ) {
		$outputDir .= ( shift ) || ".";
	} else {
		$filename = $a;
	}
}

&ReadBIO;

if ( $errors > 0 ) {
	die "*** $errors errors.\n";
}

&WriteH;
&WriteC;
