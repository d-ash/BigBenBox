#
# PerlPP (PPP): Perl preprocessor
#
# Usage: perl perlpp.pl [options] <inFilename> <outFilename>
#
# Some info about scoping in Perl:
# http://darkness.codefu.org/wordpress/2003/03/perl-scoping/
#

package PerlPP;

use strict;
use warnings;

use constant TAG_OPEN => "<?";
use constant TAG_CLOSE => "?>";
use constant OPENING_RE => qr/^(.*?)\Q${\(TAG_OPEN)}\E(.*)$/;
use constant CLOSING_RE => qr/^(.*?)\Q${\(TAG_CLOSE)}\E(.*)$/;

my $argCommentsType = "";
my $argEval = "";
my $argDebug = 0;

my $filename = "";
my $outFilename = "";
my $package = "";
my $echoMode = 0;
my $commandMode = 0;
my $command = "";
my $catching = 0;
my $wasCatched = 0;
my $code = "";
my $f;
my @PerlPP_ob = ();				# sequence of output buffers
my $rootSTDOUT;
my $PerlPP_cGuard = "";
my %PerlPP_prefixes = ();
my %PerlPP_cleanups = ();

sub StartOB {
	if ( scalar @PerlPP_ob == 0 ) {
		open( $rootSTDOUT, ">&STDOUT" ) or die $!;		# dup filehandle
	}
	push( @PerlPP_ob, "" );
	close( STDOUT );			# must be closed before redirecting it to a variable
	open( STDOUT, ">", \$PerlPP_ob[ $#PerlPP_ob ] ) or die $!;
	$| = 1;						# do not use output buffering
}

sub EndOB {
	my $s;

	$s = pop( @PerlPP_ob );
	close STDOUT;
	if ( scalar @PerlPP_ob == 0 ) {
		open( STDOUT, ">&", $rootSTDOUT ) or die $!;	# dup filehandle
		$| = 0;					# return output buffering to the default state
	} else {
		open( STDOUT, ">", \$PerlPP_ob[ $#PerlPP_ob ] ) or die $!;
	}
	return $s;
}

sub ReadOB {
	my $s;

	$s = $PerlPP_ob[ $#PerlPP_ob ];
	$PerlPP_ob[ $#PerlPP_ob ] = "";
	return $s;
}

#	print "start " .
#		eval { &StartOB; print "X" .
#			eval { &StartOB; print "Y"; return &EndOB; } .
#		"Z"; return &EndOB; } .
#	" end\n";

sub OutputPlain {
	my $_;
	my $plain;

	$plain = &ReadOB;
	foreach ( keys %PerlPP_prefixes ) {
		$plain =~ s/(^|\W)\Q$_\E/$1$PerlPP_prefixes{ $_ }/g;
	}
	$plain =~ s/\\/\\\\/g;
	$plain =~ s/'/\\'/g;

	if ( $catching ) {
		if ( $commandMode ) {
			$command .= "'${plain}'";
		} else {
			$code .= "'${plain}'";
		}
	} else {
		$code .= "print '${plain}';\n";
	}
}

sub OutputComments {
	my $prefix = "";

	if ( $argCommentsType eq "doubleslash" ) {
		$prefix = "//";
	} elsif ( $argCommentsType eq "hash" ) {
		$prefix = "#";
	} else {
		print STDERR "Unknown type of comments style.\n";
		return;
	}

	print( "${prefix} This file is automatically generated by perlpp.pl\n" );
	print( "${prefix}   source: $filename\n" );
	print( "${prefix}   package: $package\n\n" );
}

sub ProcessCommand {
	my $cmd = shift;

	if ( $cmd =~ /^prefix\s+(\S+)\s+(\S+)\s*$/i ) {
		$PerlPP_prefixes{ $1 } = $2;
	} elsif ( $cmd =~ /^c:guard\s*$/i ) {
		$PerlPP_cGuard = "_PPP_CGUARD_" . uc( $package );
		print "#ifndef ${PerlPP_cGuard}\n#define ${PerlPP_cGuard}\n"
	} elsif ( $cmd =~ /^c:onCleanup\s+([a-zA-Z_][a-zA-Z_0-9]*)\s+(.*)$/is ) {
		print STDERR "c:onCleanup $1 $2\n";
	} elsif ( $cmd =~ /^c:gotoCleanup\s*$/i ) {
		print STDERR "c:gotoCleanup\n";
	} elsif ( $cmd =~ /^c:cleanup\s*$/i ) {
		print STDERR "c:cleanup\n";
	} else {
		die "Unknown command: ${cmd}";
	}
}

while ( my $a = shift ) {
	if ( $a eq "--eval" ) {
		$argEval .= ( shift ) || "";
	} elsif ( $a eq "--debug" ) {
		$argDebug = 1;
	} elsif ( $a eq "--comments" ) {
		$argCommentsType = ( shift ) || "";
	} else {
		$filename = $a;
		( $outFilename = shift ) or die "Usage: perl perlpp.pl [options] <inFilename> <outFilename>";
	}
}

$package = $filename;
$package =~ s/^([a-zA-Z_][a-zA-Z_0-9.]*).p$/$1/;
$package =~ s/[.\/\\]/_/g;
&StartOB;
$code = "package PPP_${package}; use strict; use warnings;\n";
$code .= "${argEval}\n";

open( $f, "<", $filename ) or die $!;

OPENING:
while ( <$f> ) {
	# 'redo OPENING' jumps in here
	if ( $_ =~ OPENING_RE ) {
		my $after = $2;
		my $inside = "";

		print $1;
		&OutputPlain;

		$wasCatched = 0;
		if ( $catching ) {
			if ( $after =~ /^"/ ) {									# end of catching
				$catching = 0;
				&EndOB;
				$wasCatched = 1;
				$_ = substr( $after, 1 ) . "\n";
			} else {												# code execution within catching
				die "Unfinished catching.";
			}
		} else {
			if ( $after =~ /^=/ ) {
				$echoMode = 1;
				$_ = substr( $after, 1 ) . "\n";
			} elsif ( $after =~ /^:/ ) {
				$commandMode = 1;
				$_ = substr( $after, 1 ) . "\n";
			} elsif ( $after =~ /^"/ ) {
				die "Unexpected end of catching, it was not started.";
			} else {
				$_ = $after . "\n";
			}
		}

		CLOSING:
		if ( $_ =~ CLOSING_RE ) {
			$inside .= $1;
			$_ = $2 . "\n";				# it will be processed after 'redo OPENING'
			if ( $inside =~ /"$/ ) {
				$inside = substr( $inside, 0, -1 );
				if ( $echoMode ) {
					# echoMode is transparent for catching
					if ( $wasCatched ) {
						$code .= $inside;							# middle part of print() statement
					} else {
						$code .= "print( ${inside}";				# start of print() statement
					}
				} elsif ( $commandMode ) {
					# commandMode is transparent for catching also
                    $command .= $inside;
				} else {
					$code .= $inside;
				}
				$catching = 1;										# catching is started or continued
				&StartOB;
			} else {
				if ( $echoMode ) {
					if ( $wasCatched ) {
						$code .= " );\n";							# end of print() statement
					} else {
						$code .= "print( ${inside} );\n";
					}
					$echoMode = 0;
				} elsif ( $commandMode ) {
                    $command .= $inside;
					ProcessCommand( $command );
					$commandMode = 0;
					$command = "";
				} else {
					$code .= $inside;
				}
			}
			redo OPENING;				# NB: redo jumps to the beginning of the inner block
		} else {
			$inside .= $_;
			$_ = <$f>;					# continue looking for $TAG_CLOSE
			goto CLOSING;
		};
	} else {
		print $_;
	}
}

if ( $catching ) {
	die "Unfinished catching.";
}
if ( $PerlPP_cGuard ) {
	print "\n#endif		// ${PerlPP_cGuard}\n";
}
&OutputPlain;
close $f or die $!;

if ( $argDebug ) {
	print STDERR $code;
	print STDERR &EndOB;
} else {
	&OutputComments;
	eval( $code );
	warn $@ if $@;
	open( $f, ">", $outFilename ) or die $!;
	print $f &EndOB;
	close( $f ) or die $!;
}
=cut
