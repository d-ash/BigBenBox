#
# Portable binary records I/O.
# Generates one .h and .c files from .bio definition.
#

use strict;
use warnings;
use Data::Dumper;

my @records = ();
my $errors = 0;
my $line = 0;
my $filename = "";
my $namespace = "";

sub Perr {
	my $s = shift;

	print "line $line: " . $s . "\n";
	$errors += 1;
}

sub ReadBIO {
	my $SYMBOL = "[a-zA-Z_][a-zA-Z_0-9]*";
	my $COMMENTS = "\\s*(?:\\/\\/.*)?";
	my $inRecord = 0;
	my $f;

	$errors = 0;
	$line = 0;

	open $f, $filename or die $!;

	for ( <$f> ) {
		$line += 1;
		if ( $_ =~ /^($SYMBOL)\s+\{$COMMENTS$/ ) {
			# record definition (begin)
			if ( $inRecord ) {
				Perr "The record ( $1 ) is inside another one.";
			} else {
				$inRecord = 1;
				push( @records, { "recName" => $1, "fields" => [] } );
			}
		} elsif ( $_ =~ /^\t($SYMBOL)\s+($SYMBOL);$COMMENTS$/ ) {
			# field definition
			if ( $inRecord ) {
				push( @{ $records[ $#records ]{ "fields" } }, {
					"type" => $1,
					"name" => $2
				} );
			} else {
				Perr "The field ( $1 $2 ) is outside of records.";
			}
		} elsif ( $_ =~ /^\};$COMMENTS$/ ) {
			# record definition (end)
			if ( $inRecord ) {
				$inRecord = 0;
			} else {
				Perr "Unexpected end of a record.";
			}
		} elsif ( $_ =~ /^$COMMENTS$/ ) {
			# skipping
		} else {
			Perr "Corrupted line.";
		}
	}

	close $f or die $!;
}

sub WriteH {
	my $def = "_" . uc( $namespace ) . "_BIO_H";
	my $f;

	open $f, ">", "$filename.h" or die $!;

	print $f "// This file is automatically generated by util_bio.pl\n";
	print $f "//   source: $filename\n";
	print $f "//   namespace: $namespace\n\n";
	print $f "#ifndef $def\n";
	print $f "#define $def\n\n";
	print $f "#include \"global.h\"\n";
	print $f "#include \"util_bio.h\"\n\n";

	foreach ( @records ) {
		my $rec = $_;
		my $recName = $rec->{ "recName" };
		my $recType = $rec->{ "recType" } = "${namespace}_${recName}_t";

		$rec->{ "dynamic" } = 0;
		print $f "typedef struct {\n";
		foreach ( @{ $rec->{ "fields" } } ) {
			if ( $_->{ "type" } eq "varbuf" ) {
				$rec->{ "dynamic" } = 1;	# dynamic memory allocation for fields
				print $f "	bbb_varbuf_t\t" . $_->{ "name" } . ";\n";
			} elsif ( $_->{ "type" } eq "uint8" ) {
				print $f "	" . $_->{ "type" } . "_t\t\t\t" . $_->{ "name" } . ";\n";
			} else {
				print $f "	" . $_->{ "type" } . "_t\t\t" . $_->{ "name" } . ";\n";
			}
		}
		print $f "} ${recType};\n\n";

		$rec->{ "proto" } = {};

		$rec->{ "proto" }{ "Copy" }
			= sprintf "int ${namespace}_Copy_${recName}( ${recType}* const dst, const ${recType}* const src )";

		$rec->{ "proto" }{ "IsEqual" }
			= sprintf "int ${namespace}_IsEqual_${recName}( const ${recType}* const r1, const ${recType}* const r2 )";

		$rec->{ "proto" }{ "GetSize" }
			= sprintf "size_t ${namespace}_GetSize_${recName}( const ${recType}* const r )";

		$rec->{ "proto" }{ "Read" }
			= sprintf "int ${namespace}_Read_${recName}( ${recType}* const r, FILE* const f )";

		$rec->{ "proto" }{ "ReadArray" }
			= sprintf "int ${namespace}_ReadArray_${recName}( ${recType}* const a, size_t const n, FILE* const f )";

		$rec->{ "proto" }{ "Write" }
			= sprintf "int ${namespace}_Write_${recName}( const ${recType}* const r, FILE* const f )";

		$rec->{ "proto" }{ "WriteArray" }
			= sprintf "int ${namespace}_WriteArray_${recName}( const ${recType}* const a, size_t const n, FILE* const f )";

		if ( $rec->{ "dynamic" } ) {
			$rec->{ "proto" }{ "Destroy" }
				= sprintf "void ${namespace}_Destroy_${recName}( ${recType}* const r )";

			$rec->{ "proto" }{ "DestroyEach" }
				= sprintf "void ${namespace}_DestroyEach_${recName}( ${recType}* const a, size_t const n )";
		}

		foreach ( sort keys %{$rec->{ "proto" }} ) {
			print $f $rec->{ "proto" }{ $_ } . ";\n";
		}

		print $f "\n";
	}

	print $f "#endif\n";
	close $f or die $!;
}

sub IsAtomType {
	return ( shift =~ m/^uint(?:8|16|32|64)$/ );
}

sub WriteC {
	my $BIO_NS = "bbb_util_bio";
	my $f;

	open $f, ">", "$filename.c" or die $!;

	print $f "// This file is automatically generated by util_bio.pl\n";
	print $f "//   source: $filename\n";
	print $f "//   namespace: $namespace\n\n";
	print $f "#include \"$filename.h\"\n";

	foreach ( @records ) {
		my $rec = $_;
		my $recName = $rec->{ "recName" };

		# Copy() implementation
		print $f "\n" . $rec->{ "proto" }{ "Copy" } . " {\n";
		print $f "	size_t	len;\n\n";
		foreach ( @{ $rec->{ "fields" } } ) {
			my $type = $_->{ "type" };
			my $name = $_->{ "name" };

			if ( IsAtomType $type ) {
				print $f "	dst->${name} = src->${name};\n";
			} elsif ( $type eq "varbuf" ) {
				print $f "	len = dst->${name}.len = src->${name}.len;\n";
				print $f "	dst->${name}.buf = malloc( len );\n";
				print $f "	if ( dst->${name}.buf == NULL ) {\n";
				print $f "		return 0;\n";
				print $f "	}\n";
				print $f "	memcpy( dst->${name}.buf, src->${name}.buf, len );\n";
			} else {
				die "Unknown field type: $type\n";
			}
		}
		print $f "\n";
		print $f "	return 1;\n";
		print $f "}\n";

		# IsEqual() implementation
		print $f "\n" . $rec->{ "proto" }{ "IsEqual" } . " {\n";
		foreach ( @{ $rec->{ "fields" } } ) {
			my $type = $_->{ "type" };
			my $name = $_->{ "name" };

			if ( IsAtomType $type ) {
				print $f "	if ( r1->${name} != r2->${name} ) {\n";
			} elsif ( $type eq "varbuf" ) {
				print $f "	if ( !bbb_util_bio_IsEqual_varbuf( r1->${name}, r2->${name} ) ) {\n";
			} else {
				die "Unknown field type: $type\n";
			}
			print $f "		return 0;\n";
			print $f "	}\n";
		}
		print $f "\n";
		print $f "	return 1;\n";
		print $f "}\n";

		# GetSize() implementation
		print $f "\n" . $rec->{ "proto" }{ "GetSize" } . " {\n";
		print $f "	return ( 0";
		foreach ( @{ $rec->{ "fields" } } ) {
			my $type = $_->{ "type" };
			my $name = $_->{ "name" };

			print $f " + ";
			if ( IsAtomType $type ) {
				print $f "sizeof( ${type}_t )";
			} elsif ( $type eq "varbuf" ) {
				print $f "sizeof( r->${name}.len ) + r->${name}.len";
			} else {
				die "Unknown field type: $type\n";
			}
		}
		print $f " );\n";
		print $f "}\n";

		# Read() implementation
		print $f "\n" . $rec->{ "proto" }{ "Read" } . " {\n";
		foreach ( @{ $rec->{ "fields" } } ) {
			my $type = $_->{ "type" };
			my $name = $_->{ "name" };

			if ( $type eq "uint8" ) {
				print $f "	if ( fread( &( r->${name} ), 1, 1, f ) == 0 ) {\n";
			} else {
				print $f "	if ( ${BIO_NS}_Read_${type}( &( r->${name} ), f ) == 0 ) {\n";
			}
			print $f "		return 0;\n";
			print $f "	}\n\n";
		}
		print $f "	return 1;\n";
		print $f "}\n";

		# ReadArray() implementation
		print $f "\n" . $rec->{ "proto" }{ "ReadArray" } . " {\n";
		print $f "	size_t	i;\n\n";
		print $f "	for ( i = 0; i < n; i++ ) {\n";
		print $f "		if ( ${namespace}_Read_${recName}( &( a[ i ] ), f ) == 0 ) {\n";
		print $f "			return 0;\n";
		print $f "		}\n";
		print $f "	}\n";
		print $f "	return 1;\n";
		print $f "}\n";

		# Write() implementation
		print $f "\n" . $rec->{ "proto" }{ "Write" } . " {\n";
		foreach ( @{ $rec->{ "fields" } } ) {
			my $type = $_->{ "type" };
			my $name = $_->{ "name" };

			if ( $type eq "uint8" ) {
				print $f "	if ( fwrite( &( r->${name} ), 1, 1, f ) == 0 ) {\n";
			} else {
				print $f "	if ( ${BIO_NS}_Write_${type}( r->${name}, f ) == 0 ) {\n";
			}
			print $f "		return 0;\n";
			print $f "	}\n\n";
		}
		print $f "	return 1;\n";
		print $f "}\n";

		# WriteArray() implementation
		print $f "\n" . $rec->{ "proto" }{ "WriteArray" } . " {\n";
		print $f "	size_t	i;\n\n";
		print $f "	for ( i = 0; i < n; i++ ) {\n";
		print $f "		if ( ${namespace}_Write_${recName}( &( a[ i ] ), f ) == 0 ) {\n";
		print $f "			return 0;\n";
		print $f "		}\n";
		print $f "	}\n";
		print $f "	return 1;\n";
		print $f "}\n";

		if ( $rec->{ "dynamic" } ) {
			# Destroy() implementation
			print $f "\n" . $rec->{ "proto" }{ "Destroy" } . " {\n";
			foreach ( @{ $rec->{ "fields" } } ) {
				my $type = $_->{ "type" };
				my $name = $_->{ "name" };

				if ( $type eq "varbuf" ) {
					print $f "	free( r->${name}.buf );\n";
					print $f "	r->${name}.buf = NULL;\n";
					print $f "	r->${name}.len = 0;\n\n";
				}
			}
			print $f "	return;\n";
			print $f "}\n";

			# DestroyEach() implementation
			print $f "\n" . $rec->{ "proto" }{ "DestroyEach" } . " {\n";
			print $f "	size_t	i;\n\n";
			print $f "	for ( i = 0; i < n; i++ ) {\n";
			print $f "		${namespace}_Destroy_${recName}( &( a[ i ] ) );\n";
			print $f "	}\n";
			print $f "}\n";
		}
	}

	close $f or die $!;
}

$filename = shift or die "Usage: perl util_bio.pl < bioFilename >\n";
if ( $filename =~ /^([a-z][a-z_0-9]+)\.bio$/ ) {
	$namespace = $1;
} else {
	die "util_bio.pl: Input file has a strange extension (must be .bio)\n";
}

ReadBIO;

if ( $errors > 0 ) {
	die "*** $errors errors.\n";
}

WriteH;
WriteC;
