#
# Portable binary records I/O.
# Generates one .h and .c files from .bio definition.
#

use strict;
use warnings;
use Data::Dumper;

my @records = ();
my $errors = 0;
my $line = 0;
my $filename = "";
my $namespace = "";

sub Perr {
	my $s = shift;

	print "line $line: " . $s . "\n";
	$errors += 1;
}

sub ReadBIO {
	my $SYMBOL = "[a-zA-Z_][a-zA-Z_0-9]*";
	my $COMMENTS = "\\s*(?:\\/\\/.*)?";
	my $inRecord = 0;
	my $f;

	$errors = 0;
	$line = 0;

	open $f, $filename or die $!;

	for ( <$f> ) {
		$line += 1;
		if ( $_ =~ /^($SYMBOL)\s+\{$COMMENTS$/ ) {
			# record definition (begin)
			if ( $inRecord ) {
				Perr "The record ( $1 ) is inside another one.";
			} else {
				$inRecord = 1;
				push( @records, { "record" => $1, "fields" => [] } );
			}
		} elsif ( $_ =~ /^\t($SYMBOL)\s+($SYMBOL);$COMMENTS$/ ) {
			# field definition
			if ( $inRecord ) {
				push( @{ $records[ $#records ]{ "fields" } }, {
					"type" => $1,
					"name" => $2
				} );
			} else {
				Perr "The field ( $1 $2 ) is outside of records.";
			}
		} elsif ( $_ =~ /^\};$COMMENTS$/ ) {
			# record definition (end)
			if ( $inRecord ) {
				$inRecord = 0;
			} else {
				Perr "Unexpected end of a record.";
			}
		} elsif ( $_ =~ /^$COMMENTS$/ ) {
			# skipping
		} else {
			Perr "Corrupted line.";
		}
	}

	close $f or die $!;
}

sub WriteH {
	my $def = "_" . uc( $namespace ) . "_BIO_H";
	my $f;

	open $f, ">", "$filename.h" or die $!;

	print $f "// This file is automatically generated by util_bio.pl\n";
	print $f "//   source: $filename\n";
	print $f "//   namespace: $namespace\n\n";
	print $f "#ifndef $def\n";
	print $f "#define $def\n\n";

	foreach ( @records ) {
		my $rec = $_;
		my $full = "${namespace}_" . $rec->{ "record" };

		print $f "typedef struct {\n";
		foreach ( @{ $rec->{ "fields" } } ) {
			my $fld = $_;

			print $f "	" . $fld->{ "type" } . "		" . $fld->{ "name" } . ";\n";
		}
		print $f "} ${full}_t;\n\n";

		$rec->{ "full" } = $full;
		$rec->{ "proto" } = {};

		$rec->{ "proto" }{ "Read" }
			= sprintf "size_t ${full}_Read( ${full}_t* const r, FILE* const f )";

		$rec->{ "proto" }{ "ReadArray" }
			= sprintf "size_t ${full}_ReadArray( ${full}_t* const a, size_t const n, FILE* const f )";

		$rec->{ "proto" }{ "Write" }
			= sprintf "size_t ${full}_Write( const ${full}_t* const r, FILE* const f )";

		$rec->{ "proto" }{ "WriteArray" }
			= sprintf "size_t ${full}_WriteArray( const ${full}_t* const a, size_t const n, FILE* const f )";

		$rec->{ "proto" }{ "Destroy" }
			= sprintf "void ${full}_Destroy( ${full}_t* const r )";

		$rec->{ "proto" }{ "DestroyEach" }
			= sprintf "void ${full}_DestroyEach( ${full}_t* const a, size_t const n )";

		foreach ( sort keys %{$rec->{ "proto" }} ) {
			print $f $rec->{ "proto" }{ $_ } . ";\n";
		}

		print $f "\n";
	}

	print $f "#endif\n";
	close $f or die $!;
}

sub WriteC {
	my $BIO_NS = "bbb_util_bio";
	my $f;

	open $f, ">", "$filename.c" or die $!;

	print $f "// This file is automatically generated by util_bio.pl\n";
	print $f "//   source: $filename\n";
	print $f "//   namespace: $namespace\n\n";
	print $f "#include \"$filename.h\"\n";
	print $f "#include \"util_bio.h\"\n\n";

	foreach ( @records ) {
		my $rec = $_;
		my $full = $rec->{ "full" };

		# Read() implementation
		print $f $rec->{ "proto" }{ "Read" } . " {\n";
		foreach ( @{ $rec->{ "fields" } } ) {
			my $fld = $_;
			my $type = $fld->{ "type" };
			my $name = $fld->{ "name" };

			if ( $type eq "uint8_t" ) {
				print $f "	if ( fread( &( r->${name} ), 1, 1, f ) == 0 ) {\n";
			} else {
				print $f "	if ( ${BIO_NS}_Read_" . ( $type =~ s/_t$//r ) . "( &( r->${name} ), f ) == 0 ) {\n";
			}
			print $f "		return 0;\n";
			print $f "	}\n\n";
		}
		print $f "	return 1;\n";
		print $f "}\n\n";

		# ReadArray() implementation
		print $f $rec->{ "proto" }{ "ReadArray" } . " {\n";
		print $f "	size_t i;\n\n";
		print $f "	for ( i = 0; i < n; i++ ) {\n";
		print $f "		if ( ${full}_Read( &( a[ i ] ) ) == 0 ) {\n";
		print $f "			return 0;\n";
		print $f "		}\n";
		print $f "	}\n";
		print $f "	return 1;\n";
		print $f "}\n\n";

		# Write() implementation
		print $f $rec->{ "proto" }{ "Write" } . " {\n";
		foreach ( @{ $rec->{ "fields" } } ) {
			my $fld = $_;
			my $type = $fld->{ "type" };
			my $name = $fld->{ "name" };

			if ( $type eq "uint8_t" ) {
				print $f "	if ( fwrite( &( r->${name} ), 1, 1, f ) == 0 ) {\n";
			} else {
				print $f "	if ( ${BIO_NS}_Write_" . ( $type =~ s/_t$//r ) . "( r->${name}, f ) == 0 ) {\n";
			}
			print $f "		return 0;\n";
			print $f "	}\n\n";
		}
		print $f "	return 1;\n";
		print $f "}\n\n";

		# WriteArray() implementation
		print $f $rec->{ "proto" }{ "WriteArray" } . " {\n";
		print $f "	size_t i;\n\n";
		print $f "	for ( i = 0; i < n; i++ ) {\n";
		print $f "		if ( ${full}_Write( &( a[ i ] ) ) == 0 ) {\n";
		print $f "			return 0;\n";
		print $f "		}\n";
		print $f "	}\n";
		print $f "	return 1;\n";
		print $f "}\n\n";

		# Destroy() implementation
		print $f $rec->{ "proto" }{ "Destroy" } . " {\n";
		print $f "	// TODO free buffers\n";
		print $f "	return;\n";
		print $f "}\n\n";

		# DestroyEach() implementation
		print $f $rec->{ "proto" }{ "DestroyEach" } . " {\n";
		print $f "	size_t i;\n\n";
		print $f "	for ( i = 0; i < n; i++ ) {\n";
		print $f "		${full}_Destroy( &( a[ i ] ) );\n";
		print $f "	}\n";
		print $f "}\n\n";
	}

	close $f or die $!;
}

$filename = shift or die "Usage: perl util_bio.pl < bioFilename >\n";
if ( $filename =~ /^([a-z][a-z_0-9]+)\.bio$/ ) {
	$namespace = $1;
} else {
	die "util_bio.pl: Input file has a strange extension (must be .bio)\n";
}

ReadBIO;

if ( $errors > 0 ) {
	die "*** $errors errors.\n";
}

WriteH;
WriteC;
