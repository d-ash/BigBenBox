#
# Portable binary records I/O.
# Generates one .h and .c files from .bio definition.
#

use strict;
use warnings;
use Data::Dumper;

my @records = ();
my $errors = 0;
my $line = 0;
my $filename = "";
my $namespace = "";

sub Perr {
	my $s = shift;

	print "line $line: " . $s . "\n";
	$errors += 1;
}

sub ReadBIO {
	my $SYMBOL = "[a-zA-Z_][a-zA-Z_0-9]*";
	my $COMMENTS = "\\s*(?:\\/\\/.*)?";
	my $inRecord = 0;
	my $f;

	$errors = 0;
	$line = 0;

	open $f, $filename or die $!;

	for ( <$f> ) {
		$line += 1;
		if ( $_ =~ /^($SYMBOL)\s+\{$COMMENTS$/ ) {
			# record definition (begin)
			if ( $inRecord ) {
				Perr "The record ( $1 ) is inside another one.";
			} else {
				$inRecord = 1;
				push( @records, { "recName" => $1, "fields" => [] } );
			}
		} elsif ( $_ =~ /^\t($SYMBOL)\s+($SYMBOL);$COMMENTS$/ ) {
			# field definition
			if ( $inRecord ) {
				push( @{ $records[ $#records ]{ "fields" } }, {
					"type" => $1,
					"name" => $2
				} );
			} else {
				Perr "The field ( $1 $2 ) is outside of records.";
			}
		} elsif ( $_ =~ /^\};$COMMENTS$/ ) {
			# record definition (end)
			if ( $inRecord ) {
				$inRecord = 0;
			} else {
				Perr "Unexpected end of a record.";
			}
		} elsif ( $_ =~ /^$COMMENTS$/ ) {
			# skipping
		} else {
			Perr "Corrupted line.";
		}
	}

	close $f or die $!;
}

sub WriteH {
	my $def = "_" . uc( $namespace ) . "_BIO_H";
	my $f;

	open $f, ">", "$filename.h" or die $!;

	print $f "// This file is automatically generated by util_bio.pl\n";
	print $f "//   source: $filename\n";
	print $f "//   namespace: $namespace\n\n";
	print $f "#ifndef $def\n";
	print $f "#define $def\n\n";
	print $f "#include \"global.h\"\n";
	print $f "#include \"util_bio.h\"\n\n";

	foreach ( @records ) {
		my $rec = $_;
		my $recName = $rec->{ "recName" };
		my $recType = $rec->{ "recType" } = "${namespace}_${recName}_t";

		$rec->{ "dynamic" } = 0;
		print $f "typedef struct {\n";
		foreach ( @{ $rec->{ "fields" } } ) {
			if ( $_->{ "type" } eq "varbuf" ) {
				$rec->{ "dynamic" } = 1;	# dynamic memory allocation for fields
				print $f "	bbb_varbuf_t\t" . $_->{ "name" } . ";\n";
			} elsif ( $_->{ "type" } eq "uint8" ) {
				print $f "	" . $_->{ "type" } . "_t\t\t\t" . $_->{ "name" } . ";\n";
			} else {
				print $f "	" . $_->{ "type" } . "_t\t\t" . $_->{ "name" } . ";\n";
			}
		}
		print $f "} ${recType};\n\n";

		$rec->{ "proto" } = {};

		$rec->{ "proto" }{ "Copy" }
			= sprintf "int		${namespace}_Copy_${recName}( ${recType}* const dst, const ${recType}* const src )";

		$rec->{ "proto" }{ "IsEqual" }
			= sprintf "int		${namespace}_IsEqual_${recName}( const ${recType}* const r1, const ${recType}* const r2 )";

		$rec->{ "proto" }{ "GetSize" }
			= sprintf "size_t	${namespace}_GetSize_${recName}( const ${recType}* const r )";

		$rec->{ "proto" }{ "GetSizeArray" }
			= sprintf "size_t	${namespace}_GetSizeArray_${recName}( const ${recType}* const a, size_t const n )";

		### Buffer I/O ###

		$rec->{ "proto" }{ "ReadFromBuf" }
			= sprintf "size_t	${namespace}_ReadFromBuf_${recName}( ${recType}* const r, const bbb_byte_t* const buf, const size_t len )";

		$rec->{ "proto" }{ "ReadFromBufArray" }
			= sprintf "size_t	${namespace}_ReadFromBufArray_${recName}( ${recType}* const a, size_t const n, const bbb_byte_t* const buf, const size_t len )";

		$rec->{ "proto" }{ "WriteToBuf" }
			= sprintf "size_t	${namespace}_WriteToBuf_${recName}( const ${recType}* const r, bbb_byte_t* const buf, const size_t len )";

		$rec->{ "proto" }{ "WriteToBufArray" }
			= sprintf "size_t	${namespace}_WriteToBufArray_${recName}( const ${recType}* const a, size_t const n, bbb_byte_t* const buf, const size_t len )";

		### File I/O ###

		$rec->{ "proto" }{ "ReadFromFile" }
			= sprintf "size_t	${namespace}_ReadFromFile_${recName}( ${recType}* const r, FILE* const f, bbb_checksum_t* const chk )";

		$rec->{ "proto" }{ "ReadFromFileArray" }
			= sprintf "size_t	${namespace}_ReadFromFileArray_${recName}( ${recType}* const a, size_t const n, FILE* const f, bbb_checksum_t* const chk )";

		$rec->{ "proto" }{ "WriteToFile" }
			= sprintf "size_t	${namespace}_WriteToFile_${recName}( const ${recType}* const r, FILE* const f, bbb_checksum_t* const chk )";

		$rec->{ "proto" }{ "WriteToFileArray" }
			= sprintf "size_t	${namespace}_WriteToFileArray_${recName}( const ${recType}* const a, size_t const n, FILE* const f, bbb_checksum_t* const chk )";

		if ( $rec->{ "dynamic" } ) {
			$rec->{ "proto" }{ "Destroy" }
				= sprintf "void	${namespace}_Destroy_${recName}( ${recType}* const r )";

			$rec->{ "proto" }{ "DestroyEach" }
				= sprintf "void	${namespace}_DestroyEach_${recName}( ${recType}* const a, size_t const n )";
		}

		foreach ( sort( keys %{$rec->{ "proto" }} ) ) {
			print $f $rec->{ "proto" }{ $_ } . ";\n";
		}

		print $f "\n";
	}

	print $f "#endif\n";
	close $f or die $!;
}

sub IsAtomType {
	return ( shift =~ m/^uint(?:8|16|32|64)$/ );
}

sub Output_ProtoImpl {
	my $f = shift;
	my $proto = shift;

	print $f "\n" . ( $proto =~ s/\t+/ /r ) . " {\n";
}

sub Output_ReadImpl {
	my $f = shift;
	my $mode = shift;		# ( Buf | File )
	my $rec = shift;
	my $recName = $rec->{ "recName" };

	Output_ProtoImpl( $f, $rec->{ "proto" }{ "ReadFrom${mode}" } );
	print $f "	size_t	cur = 0;\n";
	print $f "	size_t	red;\n\n";
	foreach ( @{ $rec->{ "fields" } } ) {
		my $type = $_->{ "type" };
		my $name = $_->{ "name" };

		if ( $type eq "uint8" ) {
			if ( $mode eq "Buf" ) {
				print $f "	if ( cur >= len ) { return 0; }\n";
				print $f "	r->${name} = *( buf + cur );\n";
			} else {
				print $f "	if ( fread( &( r->${name} ), 1, 1, f ) == 0 ) { return 0; }\n";
				print $f "	bbb_util_hash_UpdateChecksum( &( r->${name} ), 1, chk );\n";
			}
			print $f "	cur++;\n";
		} else {
			if ( $mode eq "Buf" ) {
				print $f "	red = bbb_util_bio_ReadFrom${mode}_${type}( &( r->${name} ), buf + cur, len - cur );\n";
			} else {
				print $f "	red = bbb_util_bio_ReadFrom${mode}_${type}( &( r->${name} ), f, chk );\n";
			}
			print $f "	if ( red == 0 ) { return 0; }\n";
			print $f "	cur += red;\n";
		}
	}
	print $f "	return cur;\n";
	print $f "}\n";
}

sub Output_ReadArrayImpl {
	my $f = shift;
	my $mode = shift;		# ( Buf | File )
	my $rec = shift;
	my $recName = $rec->{ "recName" };

	Output_ProtoImpl( $f, $rec->{ "proto" }{ "ReadFrom${mode}Array" } );
	print $f "	size_t	i;\n";
	print $f "	size_t	cur = 0;\n";
	print $f "	size_t	red;\n\n";
	print $f "	for ( i = 0; i < n; i++ ) {\n";
	if ( $mode eq "Buf" ) {
		print $f "		red = ${namespace}_ReadFrom${mode}_${recName}( &( a[ i ] ), buf + cur, len - cur );\n";
	} else {
		print $f "		red = ${namespace}_ReadFrom${mode}_${recName}( &( a[ i ] ), f, chk );\n";
	}
	print $f "		if ( red == 0 ) { return 0; }\n";
	print $f "		cur += red;\n";
	print $f "	}\n";
	print $f "	return cur;\n";
	print $f "}\n";
}

sub Output_WriteImpl {
	my $f = shift;
	my $mode = shift;		# ( Buf | File )
	my $rec = shift;
	my $recName = $rec->{ "recName" };

	Output_ProtoImpl( $f, $rec->{ "proto" }{ "WriteTo${mode}" } );
	print $f "	size_t	cur = 0;\n";
	print $f "	size_t	wtn;\n\n";
	foreach ( @{ $rec->{ "fields" } } ) {
		my $type = $_->{ "type" };
		my $name = $_->{ "name" };

		if ( $type eq "uint8" ) {
			if ( $mode eq "Buf" ) {
				print $f "	if ( cur >= len ) { return 0; }\n";
				print $f "	*( buf + cur ) = r->${name};\n";
			} else {
				print $f "	bbb_util_hash_UpdateChecksum( &( r->${name} ), 1, chk );\n";
				print $f "	if ( fwrite( &( r->${name} ), 1, 1, f ) == 0 ) { return 0; }\n";
			}
			print $f "	cur++;\n";
		} else {
			if ( $mode eq "Buf" ) {
				print $f "	wtn = bbb_util_bio_WriteTo${mode}_${type}( r->${name}, buf + cur, len - cur );\n";
			} else {
				print $f "	wtn = bbb_util_bio_WriteToFile_${type}( r->${name}, f, chk );\n";
			}
			print $f "	if ( wtn == 0 ) { return 0; }\n";
			print $f "	cur += wtn;\n";
		}
	}
	print $f "	return cur;\n";
	print $f "}\n";
}

sub Output_WriteArrayImpl {
	my $f = shift;
	my $mode = shift;		# ( Buf | File )
	my $rec = shift;
	my $recName = $rec->{ "recName" };

	Output_ProtoImpl( $f, $rec->{ "proto" }{ "WriteTo${mode}Array" } );
	print $f "	size_t	i;\n";
	print $f "	size_t	cur = 0;\n";
	print $f "	size_t	wtn;\n\n";
	print $f "	for ( i = 0; i < n; i++ ) {\n";
	if ( $mode eq "Buf" ) {
		print $f "		wtn = ${namespace}_WriteTo${mode}_${recName}( &( a[ i ] ), buf + cur, len - cur );\n";
	} else {
		print $f "		wtn = ${namespace}_WriteTo${mode}_${recName}( &( a[ i ] ), f, chk );\n";
	}
	print $f "		if ( wtn == 0 ) { return 0; }\n";
	print $f "		cur += wtn;\n";
	print $f "	}\n";
	print $f "	return cur;\n";
	print $f "}\n";
}

sub WriteC {
	my $f;

	open $f, ">", "$filename.c" or die $!;

	print $f "// This file is automatically generated by util_bio.pl\n";
	print $f "//   source: $filename\n";
	print $f "//   namespace: $namespace\n\n";
	print $f "#include \"$filename.h\"\n";

	foreach ( @records ) {
		my $rec = $_;
		my $recName = $rec->{ "recName" };

		# Copy() implementation
		Output_ProtoImpl( $f, $rec->{ "proto" }{ "Copy" } );
		print $f "	size_t	len;\n\n";
		foreach ( @{ $rec->{ "fields" } } ) {
			my $type = $_->{ "type" };
			my $name = $_->{ "name" };

			if ( IsAtomType $type ) {
				print $f "	dst->${name} = src->${name};\n";
			} elsif ( $type eq "varbuf" ) {
				print $f "	len = dst->${name}.len = src->${name}.len;\n";
				print $f "	dst->${name}.buf = malloc( len );\n";
				print $f "	if ( dst->${name}.buf == NULL ) {\n";
				print $f "		return 0;	// ignoring this fatal error of malloc()\n";
				print $f "	}\n";
				print $f "	memcpy( dst->${name}.buf, src->${name}.buf, len );\n";
			} else {
				die "Unknown field type: $type\n";
			}
		}
		print $f "\n";
		print $f "	return 1;\n";
		print $f "}\n";

		# IsEqual() implementation
		Output_ProtoImpl( $f, $rec->{ "proto" }{ "IsEqual" } );
		foreach ( @{ $rec->{ "fields" } } ) {
			my $type = $_->{ "type" };
			my $name = $_->{ "name" };

			if ( IsAtomType $type ) {
				print $f "	if ( r1->${name} != r2->${name} ) {\n";
			} elsif ( $type eq "varbuf" ) {
				print $f "	if ( !bbb_util_bio_IsEqual_varbuf( r1->${name}, r2->${name} ) ) {\n";
			} else {
				die "Unknown field type: $type\n";
			}
			print $f "		return 0;\n";
			print $f "	}\n";
		}
		print $f "\n";
		print $f "	return 1;\n";
		print $f "}\n";

		# GetSize() implementation
		Output_ProtoImpl( $f, $rec->{ "proto" }{ "GetSize" } );
		print $f "	return ( 0";
		foreach ( @{ $rec->{ "fields" } } ) {
			my $type = $_->{ "type" };
			my $name = $_->{ "name" };

			print $f " + ";
			if ( IsAtomType $type ) {
				print $f "sizeof( ${type}_t )";
			} elsif ( $type eq "varbuf" ) {
				print $f "sizeof( r->${name}.len ) + r->${name}.len";
			} else {
				die "Unknown field type: $type\n";
			}
		}
		print $f " );\n";
		print $f "}\n";

		# GetSizeArray() implementation
		Output_ProtoImpl( $f, $rec->{ "proto" }{ "GetSizeArray" } );
		print $f "	size_t	i;\n";
		print $f "	size_t	sz = 0;\n\n";
		print $f "	for ( i = 0; i < n; i++ ) {\n";
		print $f "		sz += ${namespace}_GetSize_${recName}( &( a[ i ] ) );\n";
		print $f "	}\n";
		print $f "	return sz;\n";
		print $f "}\n";

		Output_ReadImpl( $f, "Buf", $rec );
		Output_ReadArrayImpl( $f, "Buf", $rec );
		Output_WriteImpl( $f, "Buf", $rec );
		Output_WriteArrayImpl( $f, "Buf", $rec );

		Output_ReadImpl( $f, "File", $rec );
		Output_ReadArrayImpl( $f, "File", $rec );
		Output_WriteImpl( $f, "File", $rec );
		Output_WriteArrayImpl( $f, "File", $rec );

		if ( $rec->{ "dynamic" } ) {
			# Destroy() implementation
			Output_ProtoImpl( $f, $rec->{ "proto" }{ "Destroy" } );
			foreach ( @{ $rec->{ "fields" } } ) {
				my $type = $_->{ "type" };
				my $name = $_->{ "name" };

				if ( $type eq "varbuf" ) {
					print $f "	free( r->${name}.buf );\n";
					print $f "	r->${name}.buf = NULL;\n";
					print $f "	r->${name}.len = 0;\n\n";
				}
			}
			print $f "	return;\n";
			print $f "}\n";

			# DestroyEach() implementation
			Output_ProtoImpl( $f, $rec->{ "proto" }{ "DestroyEach" } );
			print $f "	size_t	i;\n\n";
			print $f "	for ( i = 0; i < n; i++ ) {\n";
			print $f "		${namespace}_Destroy_${recName}( &( a[ i ] ) );\n";
			print $f "	}\n";
			print $f "}\n";
		}
	}

	close $f or die $!;
}

$filename = shift or die "Usage: perl util_bio.pl < bioFilename >\n";
if ( $filename =~ /^([a-z][a-z_0-9]+)\.bio$/ ) {
	$namespace = $1;
} else {
	die "util_bio.pl: Input file has a strange extension (must be .bio)\n";
}

ReadBIO;

if ( $errors > 0 ) {
	die "*** $errors errors.\n";
}

WriteH;
WriteC;
